\section{Реализация поискового механизма}


\subsection{Выбор инструмента}

Теоретически функциональность поиска можно было реализовать, используя
встроенные средсва СУБД, например, like для MySQL и другое.
Но на практике это неразумно, так как реализация подобной задачи 
достаточно трудоёмка.
И, не зависимо от пути реализации, скорость работы такого механизма была бы неприемлема низка.
Естественно, подобная задача важна и широко распространена.
Пoэтому существуют достаточно много готовых решений, называемых поисковыми системами.
Вот неполный список одних из самых популярных решений:
\begin{enumerate}
    \item The Apache Lucene 
    \item Xapian
    \item Sphinx
    \item Яндекс.Сервер
\end{enumerate}

Все они предоставляют схожую функциональность.

Для реализации интерфейса поискового механизма в этом проекте был выбран Sphinx. 
Это бесплатная поисковая система с открытым исходным кодом, 
предназначенная для быстрого поиска текста. 
Автор проекта --- россиянин Андрей Аксёнов.

\subsection{Реализация поиска с помощью Sphinx}

Процесс осуществления поиска состоит из двух этапов.

Первый --- это индексация данных, то есть преобразование входных данных и добавление их в некоторую базу.
Затем эта база используется для полнотекстового поиска информации.
Sphinx предоставляет большое число возможных настроек процесса индексации.
Второй этап --- это непосредственно поиск. Sphinx также предлагает богатые возможности тонкой настройки вида поиска.

Настройки процессов индексации и поиска позволяют реализовать требуемую функциональность поиска.

\subsubsection{Релевантный поиск}

Sphinx допускает несколько вариантов сортировки результатов поиска.
Один из них SPH\_SORT\_RELEVANCE вариант, обеспечивающий сортировку результатов по релевантности.

\subsubsection{Поиск с учётом морфологии}

Поиск с учётом морфологии в поисковых системах зачастую реализуется с помощью стемминга. Стемминг --- это процесс нахождения основы слова для заданного исходного слова.
Основная идея заключается в неразличении слов, находящихся в раздичных словоформах.
Очевидно, что такое преобразование необходимо как на стадии индексации данных, так и на стадии поиска; в последнем случае преобразование происходит над поисковым запросом.
В Sphinx существует встроенный стемминг для английского и русского языков.
Но есть возможность подключить любой другой алгоритм стемминга.
Включается данная опция в настройках индексации 
\begin{verbatim}
morphology = stem_enru
\end{verbatim}
\subsubsection{Поиск с опечатками}

При поиске книг у пользователя есть возможность указать или название книги, или имя автора, или оба параметра. В каждом из этих запросов пользователь может допустить опечатку или ошибку.
Исправление опечаток в запросе при указании названия книги осуществляется с помощью aspell. 
Aspell --- это свободная программа для исправления орфографии.
Для проверки орфографии используется словарь. 
Проверяемое слово сравнивается со словами, находящимися в словаре.
В случае, если проверяемое слово определено как неправильное, aspell может предложить варианты исправления. Так как в основе механизма исправления слов лежит словарь, то, очевидно, для различных языков такие словари будут различны. Для aspell существуют словари для более 84х языков,
среди которых есть и русский.

При использовании системы пользователь может искать книги на различных языках. Пользователь может включить фильтрацию по языкам, но может и не указывать язык.
В реализации функции исправления запроса был применён следующий приём.
Если указан язык на котором написан запрос, то программа использует соответствующий словарь; если такового не имеется в системе, то проверка орфографии не производится. Сообщение об отсутствии требуемого словаря записывается в лог.
Таким образом, проанализировав лог, можно понять, какие словари более всего требуются пользователям. Достаточно их установить в систему, и программа в следующие разы будет по необходимости использовать новые словари.

Если язык запроса не указан, то программа пытается автоматически распознать язык.
Пока это реализовано только для русского языка, в остальных случаях используется словарь анлийского языка.

Метод проверки запросов по словарю хорошо работает для обычной лексики. Но с именами нарицательными ситуация несколько хуже.

Если в русском языке чаще можно правильно записать фамилию или имя на слух, то в английском языке это почти всегда непросто.
Поэтому для осуществления поиска по авторам с опечатками в запросе применияется совершенно другая идея.
Для решения задачи поиска имён по звучанию используется алгоритм сравнения двух строк по их звучанию.
Основная идея таких алгоритмов заключается в сопоставлении слову некоторого ключа, характеризующего его звучание, а не написание.
Подобных алгоритмов существует несколько видов: Soundex, Metaphone, Double Metaphone.

Sphinx имеет встроенную поддержку как и Soundex, так и Metaphone. Подобная опция устанавливается в настройках индексатора
\begin{verbatim}
morphology = soundex
\end{verbatim}

Но при таком решении возникает небольшая проблема: в результатах поиска автор, имя которого полностью совпадает с поисковым запросом, может оказаться не на первом месте. А на первом месте может оказаться автор, имя которого звучит также как и запрос.

Дабы решить эту проблему была применена следующая идея. 
Сначала авторы ищутся в индексе, с отключенной морфологией, после --- в индексе с включённой морфологией.
Затем эти результаты объединяются таким образом, что вначале идут авторы из первого результата, а после --- из второго.

\subsubsection{Проблема диакритических знаков}

Как и в названиях книг, так и в именах их авторов могут встречаться символы с различными надстрочными, подстрочными знаками, называемыми {\em диакритическими знаками}. Естественно, пользователь может указать подобные символы в поисковом запросе.
Есть мысль, что если в запросе есть диакритические знаки, то искать хочется с учётом оных. С одной стороны, это так: пример тому слово "marché" (фр."рынок") и "marche" (фр."ходит"). 

Но тут возникает проблема. Пользователь может указать в слове (или запросе) только часть необходимых диакритических знаков, тогда, скорее всего, он получит результат хуже, чем при запросе без диакритических знаков. 

Для такого поведения пользователя есть несколько причин:
\begin{enumerate}
    \item Просто лень, невнимательность 
    \item Отсутствие требуемого символа на клавиатуре (француз ищет книгу на испанском) 
    \item Пользователь не знает правильное написание фамили автора, но правильно указал диакритический знак в названии книги 
\end{enumerate}

Поэтому было принято решение: не различать буквы с диакритическими знаками и без.

В программе в работе со строками используется Юникод.
В Юникоде символы, имеющие дополнительные над- или подстрочные элементы, 
могут быть представлены в виде построенной по определённым правилам последовательности кодов (составной вариант, composite character) 
или в виде единого символа (монолитный вариант, precomposed character).

Для игнорирования диакритических знаков в составном варианте достаточно указать в настройках индекса Sphinx "игнорировать модифицирующие символы"
\begin{verbatim}
ignore_chars = U+0300, U+0301, U+0302, U+0303, U+0304, U+0305, ...
\end{verbatim}
Для игнорирования диакритики в едином символе используется возможность Sphinx определять таблицу символов. Она позволяет задавать правила для отображения одних сиволов в другие.
Эти правила будут использоваться как для данных при индексации, так и для поисковых запросов при поиске.
\begin{verbatim}
charset_table = U+00C0->a, U+00C1->a, ...
\end{verbatim}

\subsubsection{Простой поиск}

Для обеспечения быстрой и удобной работы с базой важную роль играет {\em простой поиск}. 
