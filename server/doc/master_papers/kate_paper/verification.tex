\section{Задача верификации данных}

Информация, поступающая от "поискового паука" (crawler) и анализатора (analyzer) зачастую бывает весьма сомнительного качества. Нужно предоставить администратору базы данных простой интерфейс для редактирования имеющейся информации. Нужно учесть, что интерфейс предназначен для использования неквалифицированными пользователями и не должен требовать от пользователя специальных навыков. Так возникает задача верификации данных.

\subsection{Реализация интерфейса администратора}

Для предоставления возможности редактировать информацию, хранящуюся на сервере, реализован инрефейс администратора.

В Django есть встроенный интерфейс администратора \cite{doc-admin, djbook-admin}. Это веб-интерфейс, доступный администраторам сайта, который предоставляет возможность добавления, редактирования и удаления содержимого сайта. Получая метаданные из описанных моделей, он предоставляет мощный интерфейс промышленного уровня, который может быть немедленно использован для наполнения сайта информацией.

Каждый тип обьектов в интерфейсе администратора обладает формой редактирования и списком обьектов. Список объектов отображает все доступные обьекты в базе данных, а форма редактирования позволяет добавлять, изменять и удалять конкретные записи. 
Разные типы полей имеют разное отображение (виджеты) --- например, поля даты/времени управляются через календарь, булево поле --- через чекбокс, текстовое поле --- обычное поле ввода. 
Автоматическая генерация интерфейса администратора удобна, но ввиду того, что это очень общая задача --- некоторые типы полей отображаются не очень удобно для редактирования. Интерфейс администратора предназначен для использования неквалифицированными пользователями и, следовательно, он должен быть самодостаточным.

\subsubsection{Автоматическая генерация интерфейса администратора}

Когда Django загружает схему URL из файла url.py  при старте сервера, выполняется функция admin.autodiscover(), которая добавиляется для активации интерфейса администрации. Эта функция проходит по элементам параметра INSTALLED\_APPS и проверяет наличие файла admin.py в каждом установленом приложении. Если файл присутствует, выполняется его код. 

Внутри файла admin.py происходит регистрация моделей в интерфейсе администратора таким образом: 

{
\small \begin{verbatim}

from django.contrib import admin
from mysite.books.models import Author, Book

admin.site.register(Author)
admin.site.register(Book)

\end{verbatim}
}

Простая настройка интерфейса администратора предоставляет немного возможностей - сделать поля необязательными, изменить метки полей, выбрать из ограниченного набора способ, которым будет отображаться поле.

Несмотря на всё это, административный интерфейс является всего навсего простым приложением Django, со своими собственными моделями, шаблонами, представлениями и схемой URL. Таким образом есть возможность настройки этого интерфейса для своего приложения.

\subsubsection{Задачи, которые не решает встроенный интерфейс}
\begin{enumerate}
	\item Отображение полей многие-ко-многим.
	\item Поиск
	\item Проверка орфографии в полях TextArea
\end{enumerate}

Одной из главных проблем интерфейса администратора является ограниченный выбор способа отображения полей со связью многие-ко-многим. Отношение многие-ко-многим  --- это отношение, при котором многие записи в одной таблице связаны со многими в другой. Такое отношение используется в работе для обеспечения связей между книгами и авторами. Такое отношение было выбрано, \tk одна книга может быть написана многими авторами, также один автор может написать несколько книг. 

В интерфейсе, предоставляемом Django, для отображения таких полей есть несколько возможностей (виджетов):
\begin{enumerate}
	\item Select --- список с возможностью множественного выбора.
	\item Filter horizontal/vertical --- два списка (horizontal/vertical определяет их относительное местоположение). Один из списков представляет собой список всех возможных вариантов выбора, второй --- выбранные элементы.
	\item Raw\_id --- представляет собой простую input-строку, с перечисленными в ней id выбранных элементов. Есть возможность добавлять новые элементы.
\end{enumerate}
Первые два варианта --- загружают в список все возможные варианты выбора целиком. Для модели, содержащей большое количество связей типа многие-ко-многим этот вариант не подходит, \tk загружать весь список становится слишком долго. Хотя, надо заметить, что на небольшом количестве таких связей такое отображение выглядит очень удобно( в использованной базе данных это отображение используется для связей тег-книга). 
Третий вариант больше подходит для отображения большого количества связей, но у него есть один недостаток --- в текстовом поле отображаются только id элементов, связанных с данным. Очень маловероятно, что человеку (администратору) будет удобно оперировать в терминах id объектов.

Таким образом возникает задача создания удобного виджета для отображения авторов, связанных с конкретной книгой.
Было решено реализовать эту связь в формате нескольких checkbox'ов, с возможностью добавлять
новые.

\subsubsection{Реализация}

При создании интерфейса администратора для каждой модели в базе данных могут создаваться классы, наследуемые от стандартного класса ModelAdmin. Такие классы предоставляют возможность настройки работы интерфейса администратора для конкретной модели. При регистрации этой модели есть возможность указать форму, которая будет использоваться при отображении. Форма указывается таким способом:

{
\small \begin{verbatim}
from django.contrib import admin
from book.forms import BookForm

class BookAdmin(admin.ModelAdmin):
    """ Admin view for model.Book"""
    form = BookForm
    raw_id_fields = ('author', 'language')
\end{verbatim}
}

При регистрации модели Book из базы данных была указана специально созданная форма для отображения --- BookForm. Далее для созания формы был написан класс, который наследуется от стандартного класса Django ModelForm. Внутри созданной формы для каждого из полей модели можно специфицировать используемый виджет.

{
\small \begin{verbatim}
class BookForm(forms.ModelForm):
    """ form for representation model.Book in admin change veiw"""
    class Meta:
        """defines model for this form """
        model = Book

    author = forms.CharField(widget=AuthorWidget(
                rel=ManyToManyRel(to=Author)), label='Authors')
\end{verbatim}
}

В примере внутри класса Meta специфицируется модель, для отображения которой будет использоваться данная форма. Далее для поля author определяется виджет, который будет использоваться. 

Так же необходимо указать способ отображения raw\_id\_fields, тогда в темплейт будут передаваться идентификаторы элементов, связанных с данным. Далее нужно создать собственный виджет для отображения данных об авторе книги AuthorWidget. 

Для обеспечения нужного поведение класс AuthorWidget наследуется от стандартных классов Django CheckboxSelectMultiple и ManyToManyRawIdWidget. Класс CheckboxSelectMultiple предоставляет методы, помогающие сконструировать виджет. Класс ManyToManyRawIdWidget предоставляет методы, позволяющие сохранить информацию в базу данных. В полученном классе осталось определить метод create\_content, который определяет содержимое виджета. Внутри метода create\_content, которому передаются идентификаторы отображаемых элементов происходит обращение к базе и по идентификатору определяются имена авторов.Так же необходимо переопределить метод render, который будет вызывать метод родительского класса CheckboxSelectMultiple, передавая ему нужные параметры -- список пар (author\_id, author\_name). Этот метод генерирут представление поля в нужном формате.

После того, как информация правильно отображена на странице нужно предоставить возможность изменять ее и правильно сохранять в базе данных. За сохранение  информации в базу данных отвечает форма BookForm, которая указана в классе ModelAdmin для модели Book. Для того, чтобы информация правильно сохранялась нужно переопределить метод save. В стандартном методе, который наследуется от родительского класса ModelForm используется метод cleaned\_data. Этот метод извлекает информацию из форм. Затем в методе save происходит проверка --- изменилась ли эта информация и, если информация изменилась, происходит ее сохранение в базу данных. Так же в этом методе происходит валидация полученных данных, при неправильном вводе -- информация не сохраняется, а пользователь получает подробное сообщение об ошибке. 

Метод cleaned\_data извлекает из checkbox не только идентификатор элемента, т.к. мы переопределили способ отображения для поля. Для сохранения поля в базу данных методу нужно передать именно идентификатор. Для этого в переопределенном методе save извлекается cleaned\_data, затем из cleaned\_data извлекается информация, связанная с виджетом, отображающим авторов. Из этой информации извлекаются идентификаторы элементов и сохраняются в изначальный словарь cleaned\_data. Затем вызывается метод save родительского класса ModelAdmin, которому передается уже изменённый словарь значений cleaned\_data. После этих действий информация появляется возможность сохранять информацию в базу.

Далее необходимо предоставить пользователю интерфейса администратора возможность добавления авторов. 

Эту возможность было решено реализовать в виде открытия (по требованию) нового окошка со списком авторов и с возможностью поиска по авторам. После того, как выбран определённый автор окошко должно закрываться, а в основном окне должен появляться checkbox с именем автора. 

Для реализации этой возможности во многом используется Javascript. В интерфейсе администратора есть возможность подключать сторонний Javascript. Для этого в той форме, для отображения которой нужно использовать Javascript это явно указывается таким образом:

{
\small \begin{verbatim}
class AuthorForm(forms.ModelForm):
    class Media:
    	model = Author
        js = ('RelatedObjectsLookups.js',)

\end{verbatim}
}

Сторонних javascript будет будет использоваться на странице со списком всевозможных авторов.

Для начала в форму, отображающую авторов нужно добавить кнопку, после нажатия которой будет вызываться вспомогательное окошко. Это делается в методе render, который переопределен для AuthorWidget. Как было сказано выше в методе render вызывается метод, генерирующий содержание виджета, а затем вызывается метод родительского класса, который возвращает сам виджет. К нему добавляется ссылка, по щелчку на которой, вызывается Javascript. Интерфейс администратора предоставляет функцию javascript, которой нужно указать ссылку, которую нужно открыть в новом окне. Эта функция называется openRelatedPopup и вызывается по щелчку. Функция открывает новое окошко со списком авторов.

При выборе автора из списка, вызывается функция dismissRelatedPopup. Эту функцию нужно адаптировать к виджету, отображающему авторов. Функция должна находить по идентификатору на странице виджет, отображающий авторов и добавлять еще один checkbox с именем автора. Проблема состоит в том, что при вызове --- этой функции передаются только идентификаторы выбранных элементов.

Для автоматической генерации темплейтов для моделей в интерфейсе администратора используется вызов функции result\_list. Внутри этой функции генерируется содержание темплейта, который будет вызван при открытии вспомогательного окошка. Чтобы передавать в Javascript нужные параметры необходимо переопределить эту функцию и явно внутри указать какие параметры будут переданы Javascript'у.

Далее в файле RelatedObjectsLookups.js, который подключается к темплейту, необходимо переопределить функцию dismissRelatedPopup так, чтобы при свертывании вспомогательного окошка рисовался новый checkbox с именем автора. 

Пройдя последовательно все эти шаги, авторы внутри книги отображаются с помощью элементов checkbox, есть возможность добавлять к книге авторов и сохранять изменения в базу данных. Аналогично можно настроить отображение любого поля с отношением многие-ко-многим.

\newpage
